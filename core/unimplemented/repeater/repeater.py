import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, simpledialog
import requests
import webbrowser
from urllib.parse import quote, urlsplit, urlunsplit
import json
from bs4 import BeautifulSoup

class HttpRequestSender(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("HTTP Request Sender")

        self.request_label = ttk.Label(self, text="Enter HTTP Request:")
        self.request_text = scrolledtext.ScrolledText(self, width=40, height=10)

        self.send_button = ttk.Button(self, text="Send Request", command=self.send_request)
        self.response_text = scrolledtext.ScrolledText(self, width=40, height=10)

        self.modify_button = ttk.Button(self, text="Modify Request", command=self.modify_request)
        self.copy_as_url_button = ttk.Button(self, text="Copy as URL", command=self.copy_as_url)
        self.toggle_method_button = ttk.Button(self, text="Toggle Method", command=self.toggle_method)
        self.copy_as_python_button = ttk.Button(self, text="Copy as Python Request", command=self.copy_as_python_request)
        self.render_response_button = ttk.Button(self, text="Render Response", command=self.render_response)
        self.pretty_print_button = ttk.Button(self, text="Pretty Print", command=self.pretty_print_response)
        self.search_button = ttk.Button(self, text="Search", command=self.search_response)

        self.setup_layout()

    def setup_layout(self):
        self.request_label.grid(row=0, column=0, columnspan=3, padx=5, pady=5, sticky=tk.W)
        self.request_text.grid(row=1, column=0, columnspan=3, padx=5, pady=5, sticky=tk.W)

        self.send_button.grid(row=2, column=0, columnspan=3, pady=10)
        self.response_text.grid(row=3, column=0, columnspan=3, padx=5, pady=5, sticky=tk.W)

        self.modify_button.grid(row=4, column=0, pady=10)
        self.copy_as_url_button.grid(row=4, column=1, pady=10)
        self.toggle_method_button.grid(row=4, column=2, pady=10)
        self.copy_as_python_button.grid(row=5, column=0, pady=10)
        self.render_response_button.grid(row=5, column=1, pady=10)
        self.pretty_print_button.grid(row=5, column=2, pady=10)
        self.search_button.grid(row=6, column=0, columnspan=3, pady=10)

    def send_request(self):
        raw_request = self.request_text.get("1.0", tk.END)
        method = self.get_method(raw_request)
        try:
            if method == "GET":
                url = self.extract_url(raw_request)
                response = requests.get(url, headers=self.parse_raw_headers(raw_request))
            elif method == "POST":
                url = self.extract_url(raw_request)
                data = self.extract_data(raw_request)
                response = requests.post(url, headers=self.parse_raw_headers(raw_request), data=data)
            else:
                tk.messagebox.showinfo("Send Request", "Unsupported HTTP method.")
                return

            self.display_response(response)
        except requests.exceptions.RequestException as e:
            self.response_text.delete("1.0", tk.END)
            self.response_text.insert(tk.END, f"Error: {e}")

    def display_response(self, response):
        self.response_text.delete("1.0", tk.END)
        self.response_text.insert(tk.END, f"HTTP/{response.raw.version} {response.status_code} {response.reason}\n")
        self.response_text.insert(tk.END, f"{response.headers}\n\n")
        self.response_text.insert(tk.END, response.text)

    def modify_request(self):
        self.request_text.config(state=tk.NORMAL)
        self.request_text.focus_set()

    def copy_as_url(self):
        raw_request = self.request_text.get("1.0", tk.END)
        url = self.extract_url(raw_request)
        if url:
            self.clipboard_clear()
            self.clipboard_append(url)
            self.update()
            tk.messagebox.showinfo("Copy as URL", f"URL copied to clipboard:\n{url}")

    def toggle_method(self):
        raw_request = self.request_text.get("1.0", tk.END)
        toggled_request = self.toggle_http_method(raw_request)
        self.request_text.delete("1.0", tk.END)
        self.request_text.insert(tk.END, toggled_request)

    def copy_as_python_request(self):
        raw_request = self.request_text.get("1.0", tk.END)
        python_request = self.convert_to_python_request(raw_request)
        self.clipboard_clear()
        self.clipboard_append(python_request)
        self.update()
        tk.messagebox.showinfo("Copy as Python Request", "Python request script copied to clipboard.")

    def render_response(self):
        response_text = self.response_text.get("1.0", tk.END)
        with open("response.html", "w") as f:
            f.write(response_text)
        webbrowser.open("response.html")

    def pretty_print_response(self):
        response_text = self.response_text.get("1.0", tk.END)
        try:
            pretty_response = json.dumps(json.loads(response_text), indent=4)
            self.response_text.delete("1.0", tk.END)
            self.response_text.insert(tk.END, pretty_response)
        except json.JSONDecodeError:
            tk.messagebox.showinfo("Pretty Print", "Response is not in JSON format.")

    def toggle_http_method(self, raw_request):
        lines = raw_request.split("\n")
        first_line_parts = lines[0].split()
        if len(first_line_parts) >= 3:
            current_method = first_line_parts[0]
            new_method = "GET" if current_method == "POST" else "POST"
            first_line_parts[0] = new_method
            lines[0] = " ".join(first_line_parts)
        return "\n".join(lines)

    def get_method(self, raw_request):
        lines = raw_request.split("\n")
        first_line_parts = lines[0].split()
        return first_line_parts[0] if first_line_parts else "GET"

    def extract_url(self, raw_request):
        lines = raw_request.split("\n")
        first_line_parts = lines[0].split()
        if len(first_line_parts) >= 2:
            method, path = first_line_parts[0], first_line_parts[1]
            host = None
            for line in lines[1:]:
                if line.lower().startswith("host:"):
                    host = line.split(":", 1)[1].strip()
                    break
            if host:
                scheme = "https" if "https://" in path else "http"
                url = urlunsplit((scheme, host, path, "", ""))
                return url
        return None

    def extract_data(self, raw_request):
        lines = raw_request.split("\n")
        data_line = None
        for line in lines[1:]:
            if line.lower().startswith("content-type: application/x-www-form-urlencoded"):
                data_line = line
                break
        if data_line:
            return data_line.split(":", 1)[1].strip()
        return None

    def parse_raw_headers(self, raw_request):
        headers = {}
        lines = raw_request.split("\n")
        for line in lines[1:]:
            if not line.strip():
                break  # Stop when an empty line is encountered
            key, value = line.split(":", 1)
            headers[key.strip()] = value.strip()
        return headers

    def search_response(self):
        text_to_find = simpledialog.askstring("Search", "Enter text to find in the response:")
        if text_to_find:
            self.response_text.tag_remove(tk.SEL, "1.0", tk.END)
            start_index = "1.0"
            while start_index:
                start_index = self.response_text.search(text_to_find, start_index, stopindex=tk.END)
                if start_index:
                    end_index = f"{start_index}+{len(text_to_find)}c"
                    self.response_text.tag_add(tk.SEL, start_index, end_index)
                    self.response_text.tag_configure(tk.SEL, background="yellow")
                    start_index = end_index
                else:
                    break
            if not self.response_text.tag_ranges(tk.SEL):
                tk.messagebox.showinfo("Search", "Text not found in the response.")

if __name__ == "__main__":
    app = HttpRequestSender()
    app.mainloop()

